---
title: "Developing the ACC-to-Loc App"
format: 
  html:
    df-print: paged
editor: source
---

This is a notebook on the development of the App tasked with downloading and
binding accelerometer data to a dataset with locations.


```{r, preamble}
#| message: false
library(dplyr)
library(move2)
library(lubridate)
library(purrr)
library(furrr)
library(magrittr)
library(bench)
library(stringr)
library(tictoc)
library(mgcv)
library(ggplot2)
library(tidyr)

# load App's main function
source("../RFunction.R")

source("../src/common/logger.R")
source("../src/common/runtime_configuration.R")

# load example datasets (individual-based)
acc_testsets <- readRDS("acc_testsets.rds")
acc_testsets_large <- readRDS("acc_testsets_large.rds")
```

## Get study IDs and individual IDs in input location data

The example location data sets shipped with the template App are not usable for
the development and testing of the current App, as we don't seem to have
permission to download data for the associated studies.

```{r}
test_inputs <- map(list.files("../data/raw/", full.names = TRUE), readRDS)
names(test_inputs) <- paste0("input", 1:length(test_inputs))

map_df(test_inputs, .id = "test_input_data",  \(x){
  movebank_download_study_info(study_id = mt_track_data(x)$study.id) |> 
    dplyr::select(sensor_type_ids, i_can_see_data:i_have_download_access)
})

# input4_track_attr <- move2::mt_track_data(test_inputs$input4)
# 
# gps_data <- move2::movebank_download_study(
#   study_id = input4_track_attr$study.id[1], 
#   sensor_type_id = "gps",
#   individual_id = input4_track_attr$individual.id[1],
#   timestamp_start = input4_track_attr$timestamp.start[1],
#   timestamp_end = input4_track_attr$timestamp.end[1],
#   #'license-md5' ='3e16cdddd8e40745d7a452d2c1cc9fea'
# )

```

Therefore, we need to create some location (i.e. gps) example data sets.


## Pre-processing of downloaded ACC data 

### Testing current Shiny functions

ACC processing performed in Shiny uses both the following functions.
```{r}
source("accMasseur_eobsVult_shiny.R")
source("accMasseur_eobsVult_updated_shiny.R")
```

These Shiny-based functions were developed to process multiple individuals at a
time, therefore embedding steps to identify the type of ACC data format
presented at input and proceed accordingly. Furthermore, these functions expect
some pre-processing steps between the download and its application, like e.g.
adding some extra columns. Therefore, we need to do some of that pre-processing
here before being able run them.

As it will be shown below, the processing of nested data is much slower than
plain data processing.

::: {.callout-note appearance="simple"}
Test sets contain observations for only a single individual.
:::

```{r}
# Nested format
acc_testsets$nested_XYZ_raw |>
  as.data.frame() |> 
  mutate(deployment_id = mt_track_data(acc_testsets$nested_XYZ_raw)$deployment_id) |> 
  accMasseur_eobsVult()
```


```{r}
# Plain format
acc_testsets$plain_XYZ_raw |>
  as.data.frame() |> 
  mutate(
    deployment_id = mt_track_data(acc_testsets$plain_XYZ_raw)$deployment_id,
    tag_id = mt_track_data(acc_testsets$plain_XYZ_raw)$tag_id,
    individual_id = mt_track_data(acc_testsets$plain_XYZ_raw)$individual_id,
    tag_local_identifier = mt_track_data(acc_testsets$plain_XYZ_raw)$tag_local_identifier,
    local_identifier = mt_track_data(acc_testsets$plain_XYZ_raw)$tag_local_identifier,
    update_ts = timestamp,
    study_name = mt_track_data(acc_testsets$plain_XYZ_raw)$name,
    dwnld_timestamp = now(),
    eobs_acceleration_axes = "") |> 
  accMasseur_eobsVult()

```


### Checking the new function: `preprocess_acc()`

`preprocess_acc()` is meant to work exclusively at the individual level

```{r}
preprocess_acc(acc_testsets$nested_XYZ_raw)
preprocess_acc(acc_testsets$nested_XY_raw)
preprocess_acc(acc_testsets$nested_with_plain_cols)
preprocess_acc(acc_testsets$plain_XYZ_raw)
preprocess_acc(acc_testsets$plain_XYZ_ms2)
preprocess_acc(acc_testsets$plain_with_nested_cols)
```


```{r}
test <- preprocess_acc(acc_testsets$plain_XYZ_raw)
test
mt_time_column(test)
mt_track_id_column(test)

```


Performance comparison with shiny version for a small nested dataset
```{r}
bench::mark(
  check = FALSE,
  {
    new_nested <- preprocess_acc(acc_testsets$nested_XYZ_raw)},
  {
    shiny_nested <- acc_testsets$nested_XYZ_raw |>
      as.data.frame() |> 
      mutate(deployment_id = mt_track_data(acc_testsets$nested_XYZ_raw)$deployment_id) |> 
      accMasseur_eobsVult()
  }
)

#check if summarised value are identical
sum(new_nested[, c("mean_acc_x", "mean_acc_y", "var_acc_x", "var_acc_y")] - shiny_nested[, c("meanx", "meany", "varx", "vary")])

```

Performance comparison with shiny version for large nested dataset
```{r}
# large nested data
tic()
acc_testsets_large$nested_XYZ_raw_large |>
      as.data.frame() |> 
      mutate(deployment_id = mt_track_data(acc_testsets$nested_XYZ_raw_large)$deployment_id) |> 
      accMasseur_eobsVult()
toc()
```

```{r}
tic()
preprocess_acc(acc_testsets_large$nested_XYZ_raw_large)
toc()
```


```{r}
tic()
preprocess_acc(acc_testsets$plain_XYZ_raw)
toc()

tic()
preprocess_acc(acc_testsets_large$plain_XYZ_raw)
toc()


out_plain <- preprocess_acc(acc_testsets$plain_XYZ_raw)

tic()
out_plain <- preprocess_acc(acc_testsets_large$plain_XYZ_raw)
toc()

out_plain

```






## Predict/estimate ACC variance given time of a day

```{r}
acc_shiny_2 |> 
  tidyr::nest(acc_dt = -c(tag, yearmonthday))

acc_shiny_2 |> 
  group_by(yearmonthday) |> 
  summarise(n())

dt_to_fit <- filter(acc_shiny_2, yearmonthday == "20140421") #"20140317") 

fit <- gam(varx+1 ~ s(hourmin, bs="ad"), family=Gamma(link="log"), data=dt_to_fit)
plot(fit)

preds <- tibble(
  grid_hm = seq(min(dt_to_fit$hourmin), max(dt_to_fit$hourmin), by = 0.25),
  gam = predict(fit, newdata = data.frame(hourmin = grid_hm), type = "response"),
  spline = spline(x=dt_to_fit$hourmin, y=dt_to_fit$varx, xout = grid_hm)$y,
  ln_intrp = approx(x=dt_to_fit$hourmin, y=dt_to_fit$varx, xout = grid_hm)$y
) |> 
  tidyr::pivot_longer(cols = -grid_hm, names_to = "method", values_to = "pred_varx")

preds |> 
  ggplot(aes(x = grid_hm, y = pred_varx, colour = method)) +
  geom_point()+
  geom_line() +
  geom_point(aes(x = hourmin, y = varx), data = dt_to_fit, inherit.aes = FALSE)

```






```{r}

testthat::test_file("../tests/testthat/test_RFunction.R")

```


